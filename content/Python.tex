\section{Python}


\subsection{Important Concepts}
Python is a language with many characteristics, ones more obvious and easy to understand, like in-fix notation, others are more complex, like Dynamic Typing and Automatic Memory Allocation.

Moreover, many programming principles like anonymous functions, map, zip are important and should be addressed in order to achieve flexible and overall good programming skills.

Beforehand, check the Python Notebook and the slides from Rodrigo Ventura in the ``Additional Material'' Folder. They are very complete and give a proper insight on how everything works.

Tuples are faster than lists. So, if the idea is doing a very big iteration where there's no memory problem, converting to tuple before probably helps. 

However, regarding speed, always use built-in functions and libraries! Almost always what is slowing the program down is a huge for loop... Libraries are compiled already and are very optimised, therefore by using them you are probably running very optimised C code, which couldn't be faster than it is.


\subsubsection{Lambda and Anonymous functions}
Lambda is the keyword used to make an anonymous function. The following 2 pieces of code do exactly the same.

\begin{lstlisting}[language=python]
    def my_key(x):
    return x[0]

    l.sort(key=my_key)


    OR

    l.sort(key = lambda x: x[1])
\end{lstlisting}

And a short example is:
\begin{lstlisting}[language=python]
    -----short example on how cool python is-----
    def make_multiplier(factor):
    return lambda x: factor*x

    f = make_multiplier(2)
    ---------------------------------------------
\end{lstlisting}

Therefore, lambda is nothing more than defining a function, without giving it a name. It helps keeping the code simple specially when the function is just going to be used once.




\subsubsection{\_\_main\_\_}
This can be perfectly understood in the following \href{https://stackoverflow.com/questions/419163/what-does-if-name-main-do}{\ul{stackoverflow post}}.

In a nutshell, when a script is executed python assigns many names to certain variables like \_\_main\_\_. Is the script is executed in the terminal, then main will be the name of that script (without the .py). The \ii{if \_\_name\_\_ == '\_\_main\_\_':} aims to distinguish between situation where the script was imported, so that the functions it contains can be used elsewhere (in this case the main name won't be the name of the script which is stored in \_\_name\_\_) and the situation where the script is directly called in the terminal. If the script is directly called, for it to do something, something has to execute and that's usually what goes inside that if. When the script is imported, most of the times only the definitions matter and the calls will be made in the script that is calling that one. 

Therefore, is a good tool in case you want to make a script importable but also callable.

\subsection{Some useful tools}
To check if a variable points to a certain data type:
\begin{lstlisting}[language=python]
    isinstance(var, [list, tuple, int])
\end{lstlisting}

\vspace{1cm}
To define functions with optional arguments and call them in the incorrect order:

\begin{lstlisting}[language=python]
    
    def draw_point(x, y, color='red', thickness=2): 
        print('x =', x, 'y =', y, 'color=', color, 'thickness=', thickness)

    x = 1
    y = 2
    draw_point(x,y,'blue', 5)

    draw_point(x,y,thickness=2, color='blue')

\end{lstlisting}



\subsubsection{Unpacking Argument Lists}

\href{https://docs.python.org/3.7/tutorial/controlflow.html#unpacking-argument-lists}{\ul{Unpacking Argument Lists}}

A very useful trick to pass many arguments at once.




\subsection{Anaconda}
Basically, it is the Python distribution. Because Python is so big, with so many packages and Python development is becoming quite big, a program to install things was created.

Go to the official Anaconda website and download the installation script for Python 3 and for Linux: \href{https://www.anaconda.com/distribution/}{\ul{anaconda.com/distribution}}


Install \href{https://linuxize.com/post/how-to-install-anaconda-on-ubuntu-18-04/}{\ul{Linuxize - How to Install Anaconda on Ubuntu 18.04}}

\subsubsection{Package Manager}
\href{https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html}{\ul{User's Guide for Package Manager}}

Has instructions on how to install non-conda packages and many other useful things. It allowed the installation of streamlit!

\subsubsection{Broken Jupyter}

Tornado 6.0 breaks jupyter notebooks. Is required to uninstall it through pip and/or pip3 and through anaconda! Downgrade to 4.5.3. (This subsubsection will probably be removed in the future when it's fixed.)



\subsubsection{Other}

(base) Problem \href{https://askubuntu.com/questions/1026383/why-does-base-appear-in-front-of-my-terminal-prompt}{\ul{Ask Ubundu (base) in terminal}} - then close and open the terminal to take effect.



\subsection{Pandas}
\href{https://towardsdatascience.com/pandas-tips-and-tricks-33bcc8a40bb9?gi=29663f5b3e5
}{\ul{Check this link :)}}




\subsection{Jupyter Notebooks}
\par Along with Anaconda comes a full installation of the most recent python version and the Jupyter Notebooks, which are awesome to write python.
\par Here are some very useful shortcuts to tame that beast:
\vspace{.5cm}

\begin{center}
    There are 2 modes of shortcutting: 
\begin{itemize}
    \item The Command Mode (when border of the cell is blue). Press ESC to 
    access this mode.
    \item The Edit Mode (when border of the cell is green). Press ENTER to access this mode.
\end{itemize}

The Edit Mode is clearly superior: 
\begin{itemize}
    \item Ctrl + Enter to run cell
    \item Shift + Enter to run cell and get directly to the next
    \item Ctrl + D to delete a whole line
    \item Ctrl + arrows jumps words (usual)
    \item Ctrl + Backspace deletes whole word (usual)
\end{itemize} 

The Command Mode can be usefull sometimes, especially when adding cells is needed, but remember that the cell has to have a blue border:
\begin{itemize}
    \item A - insert cell before
    \item B - insert cell after
    \item DD - delete current cell
    \item Z - undo cell deletion
    \item M - markdown input type (Check: \href{https://gtribello.github.io/mathNET/assets/notebook-writing.html}{\ul{Netbook MarkDown}})
\end{itemize}


\end{center}



\subsection{Spyder}

Jupyter Notebooks is very fun for prototyping, however, to hard debug and develop some complex stuff, Spyder is the tool.

Install Anaconda. It is the absolute best way of getting everything up to date and running smoothly with the least complications. Check \href{https://linuxize.com/post/how-to-install-anaconda-on-ubuntu-18-04/}{\ul{here}} for the complete tutorial on how to do so (very easy).

After installing Anaconda, check the \href{https://github.com/spyder-ide/spyder/releases}{\ul{Official Spyder Releases github page}} and install the most recent one. \bb{Also remember never to run pip install spyder or similar or it can completely break Anaconda installation}.




Some useful shortcuts in Spyder:
\begin{itemize}
    \item Add \# \% \% to separate cells.
    \item Ctrl + Enter - Run cell
    \item Alt + Ctrl + Enter - Debug cell
    \item Ctrl + Shift + I - Go to Console
    \item Ctrl + Shift + E - Go to Editor
\end{itemize}

Note: spyder debugger is fucking shit. You can't get comfortably inside functions. VS Code does the job fairly well for the time being.


\subsection{Keras - A powerful API for TensorFlow}

Keras is simply the way of doing neural networks. It can't get easier than that!
TensorFlow was created by Google and PyTorch, it's rival, was created by Facebook. Not only is Google a better company in terms of the use of NN to do things, but 
\href{https://towardsdatascience.com/tensorflow-vs-pytorch-vs-keras-for-nlp-exxact-8e51dd13c3f5}{\ul{this website}} also agrees that TensorFlow 2.0 is a complete game changer since it also declares keras as it's main API, therefore making it very very easy to do complex computations.

Overall, two things are fundamental to have success with these tools: 
\begin{enumerate}
    \item To understand the functions and what all options mean, is necessary to have many mathematical expression in the head
    \item Have a very good control of the API - Keras. This section will take care of this step, trying, as best as possible, to explain the first step as well.
\end{enumerate}

However, learning how to use the api can take a while. Following are the main parts of a NN.

\subsubsection{Basic Flow - Image Classification Example}

\begin{lstlisting}[language = python]
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import tensorflow.keras as keras 
from keras import utils, models, layers, callbacks, optimizers
from sklearn.metrics import confusion_matrix, accuracy_score

\end{lstlisting}

\subsubsection{Sequential Model}
There are Sequential and Functional Models. Functional is when the mess it too big. Very likely not be needed since Sequential can do much more that I know how to do, including image analysis, convolutional and recurrent NN.
To learn the basic steps of it:
\href{https://keras.io/getting-started/sequential-model-guide/}{\ul{Keras-Getting started with the Sequential Model}}
And to learn the detailed methods of it and their functions:
\href{https://keras.io/models/sequential/}{\ul{The Sequential Model - all steps}}

\subsubsection{An optimizer}

An optimizer is one of the two arguments required for compiling a Keras model - optimizes the casual gradient descent algorithm to achieve a faster convergence, i.e to find the minimum faster. We've seen a few methods on adaptive step size and momentums.
\begin{lstlisting}[language=python]
    model.add(Dense(32, input_dim=784))
    model.add(Dense(32, input_shape=(784,)))    
\end{lstlisting}

They are equivalent and both simply mean: Add a fully connected layer with 32 outputs and 784 one dimensional inputs.



\subsection{Plotting}

Very similar to MATLAB, but different.


It all depends on all complex you want to go.

Way 1:
\begin{lstlisting}[language=python]
    plt.subplot(1,2,1) #n_rows, n_cols, index
    plt.plot(x,y) #or sns.heatmap...
    plt.xlabel("hey")
    plt.ylabel("no")
    plt.title("yello")
\end{lstlisting}


Way 2:
\begin{lstlisting}[language=python]
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15,5))
    fig.suptitle('Confusion Matrices comparison')

    sns.heatmap(matrix,annot=True,cbar=False, ax = ax1) %#ax1.plot(x, y)
    ax2.set(xlabel='True Label', ylabel='Predicted Label')
    ax1.set_title('With EarlyStopping')

    sns.heatmap(matrix2,annot=True,cbar=False, ax = ax2)
    ax2.set_title('Without EarlyStopping')
    ax2.set(xlabel='True Label', ylabel='Predicted Label')
\end{lstlisting}


Way 3 - a great midterm between the other two:
\begin{lstlisting}[language=python]
    f = plt.figure(figsize=(10,3))

    ax1 = plt.subplot(1,2,1)
    sns.heatmap(matrix,annot=True,cbar=False, ax = ax1)

    ax2 = plt.subplot(1,2,2)
    sns.heatmap(matrix2,annot=True,cbar=False, ax = ax2)
    plt.title("helo")    
\end{lstlisting}




\href{https://stackoverflow.com/questions/10388462/matplotlib-different-size-subplots}{\ul{In case is necessary to have plots of different sizes}}












\subsection{Artificial Intelligence: A Modern Approach - Search Configuration}

Clone the 3 repositories below.

\href{https://github.com/aimacode/aima-python}{\ul{Aima Code}}

\href{https://github.com/aimacode/aima-data/tree/f6cbea61ad0c21c6b7be826d17af5a8d3a7c2c86}{\ul{Aima Data}}

\href{https://github.com/jiffyclub/ipythonblocks/blob/master/ipythonblocks/ipythonblocks.py}{\ul{ipythonblocks GitHub}}

Then put the ipythonblocks.py and the data folder inside the aima-python folder. That way the Jupyter notebooks should work

\subsection{From Python 2 to Python 3}
In Linux, if 2to3 is installed, one may simply run:
\begin{lstlisting}[language=bash]
    2to3 -w -n file.py    
\end{lstlisting}
This will write the file translated into python 3 in the same file(-w) and without creating a backup(-n).


\subsection{Good Practices for Python Code}

This section is irrelevant if you only code alone for yourself. In case someone else will see your code, then you should write it as everyone else likes it. You'll probably agree with most if not all of these guidelines.

\href{https://www.python.org/dev/peps/pep-0008/}{\ul{Style Guide for Python Code}}

Some of the ones I tend to violate the most:
\begin{itemize}
    \item Variable names with underscore (underline)
\end{itemize}
